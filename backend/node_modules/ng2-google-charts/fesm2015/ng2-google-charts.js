import { __awaiter, __decorate, __param, __metadata } from 'tslib';
import { EventEmitter, ɵɵdefineInjectable, ɵɵinject, LOCALE_ID, Injectable, Inject, Optional, Output, ElementRef, Input, Component, NgModule } from '@angular/core';

let GoogleChartsLoaderService = class GoogleChartsLoaderService {
    constructor(localeId, googleChartsSettings) {
        this.googleChartsSettings = googleChartsSettings;
        this.googleScriptLoadingNotifier = new EventEmitter();
        this.googleScriptIsLoading = false;
        this.localeId = localeId;
        this.loadGoogleChartsScriptPromise = new Promise((resolve, reject) => {
            if (typeof google !== 'undefined' && google.charts) {
                resolve();
            }
            else if (!this.googleScriptIsLoading) {
                this.googleScriptIsLoading = true;
                const script = document.createElement('script');
                script.type = 'text/javascript';
                script.src = 'https://www.gstatic.com/charts/loader.js';
                script.async = true;
                script.defer = true;
                script.onload = () => {
                    this.googleScriptIsLoading = false;
                    this.googleScriptLoadingNotifier.emit(true);
                    resolve();
                };
                script.onerror = () => {
                    this.googleScriptIsLoading = false;
                    this.googleScriptLoadingNotifier.emit(false);
                    reject();
                };
                document.getElementsByTagName('head')[0].appendChild(script);
            }
            else {
                this.googleScriptLoadingNotifier.subscribe((loaded) => {
                    if (loaded) {
                        resolve();
                    }
                    else {
                        reject();
                    }
                });
            }
        });
    }
    load(settings) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadGoogleChartsScriptPromise;
            yield new Promise((resolve) => {
                if (!settings) {
                    settings = Object.create(this.googleChartsSettings);
                }
                if (!settings) {
                    settings = {};
                }
                if (!settings.language) {
                    settings.language = this.localeId;
                }
                if (!settings.googleChartsVersion) {
                    settings.googleChartsVersion = '47';
                }
                const _settings = settings;
                _settings.callback = resolve;
                google.charts.load(settings.googleChartsVersion, _settings);
            });
        });
    }
};
GoogleChartsLoaderService.ɵprov = ɵɵdefineInjectable({ factory: function GoogleChartsLoaderService_Factory() { return new GoogleChartsLoaderService(ɵɵinject(LOCALE_ID), ɵɵinject("googleChartsSettings", 8)); }, token: GoogleChartsLoaderService, providedIn: "root" });
GoogleChartsLoaderService = __decorate([
    Injectable({
        providedIn: 'root'
    }),
    __param(0, Inject(LOCALE_ID)),
    __param(1, Inject('googleChartsSettings')), __param(1, Optional()),
    __metadata("design:paramtypes", [String, Object])
], GoogleChartsLoaderService);

class GoogleChartsDataTable {
    constructor(opt) {
        this.opt = opt;
        this.dataTableChanged = new EventEmitter();
        if (opt) {
            this._setDataTable(opt.dataTable, opt.firstRowIsData);
        }
    }
    send() {
        if (this.query === undefined) {
            return;
        }
        this.query.send((queryResponse) => {
            this.setDataTable(queryResponse.getDataTable());
            if (this.opt.queryCallback) {
                this.opt.queryCallback(queryResponse);
            }
        });
    }
    init(opt) {
        if (opt) {
            this.opt = opt;
        }
        if (this.tid !== undefined) {
            // doesn't work, see https://github.com/google/google-visualization-issues/issues/2381
            // this.query.abort();
            window.clearInterval(this.tid);
            this.tid = undefined;
        }
        if (this.opt.dataSourceUrl) {
            this.query = new google.visualization.Query(this.opt.dataSourceUrl);
            if (this.opt.query) {
                this.query.setQuery(this.opt.query);
            }
            if (this.opt.timeout !== undefined) {
                this.query.setTimeout(this.opt.timeout);
            }
            if (this.opt.refreshInterval) {
                // this.query.setRefreshInterval(this.opt.refreshInterval);
                this.tid = window.setInterval(() => {
                    this.send();
                }, this.opt.refreshInterval * 1000);
            }
            this.send();
        }
        else {
            this.setDataTable(this.opt.dataTable);
        }
    }
    /**
     * @returns Underlying google.visualization.DataTable
     */
    getDataTable() {
        return this.dataTable;
    }
    setDataTable(dt, firstRowIsData) {
        if (firstRowIsData === undefined) {
            firstRowIsData = this.opt.firstRowIsData;
        }
        this._setDataTable(dt, firstRowIsData);
        this.dataTableChanged.emit(this.dataTable);
    }
    _setDataTable(dt, firstRowIsData) {
        if (Array.isArray(dt)) {
            dt = google.visualization.arrayToDataTable(dt, firstRowIsData);
        }
        this.dataTable = dt;
        this.reformat();
    }
    /**
     * Applies formatters to data columns, if defined
     */
    reformat() {
        const dt = this.dataTable;
        if (dt === undefined) {
            return;
        }
        if (this.opt.formatters === undefined) {
            return;
        }
        for (const formatterConfig of this.opt.formatters) {
            let formatter;
            if (formatterConfig.type === 'PatternFormat') {
                const fmtOptions = formatterConfig.options;
                formatter = new google.visualization.PatternFormat(fmtOptions.pattern);
                formatter.format(dt, formatterConfig.columns, fmtOptions.dstColumnIndex);
                continue;
            }
            const formatterConstructor = google.visualization[formatterConfig.type];
            const formatterOptions = formatterConfig.options;
            formatter = new formatterConstructor(formatterOptions);
            if (formatterConfig.type === 'ColorFormat' && formatterOptions) {
                const fmtOptions = formatterOptions;
                for (const range of fmtOptions.ranges) {
                    if (typeof (range.fromBgColor) !== 'undefined'
                        && typeof (range.toBgColor) !== 'undefined') {
                        formatter.addGradientRange(range.from, range.to, range.color, range.fromBgColor, range.toBgColor);
                    }
                    else {
                        formatter.addRange(range.from, range.to, range.color, range.bgcolor);
                    }
                }
            }
            for (const col of formatterConfig.columns) {
                formatter.format(dt, col);
            }
        }
    }
}
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GoogleChartsDataTable.prototype, "dataTableChanged", void 0);

class ChartHTMLTooltip {
    constructor(el) {
        this.el = el;
    }
    setPosition(x, y) {
        this.el.nativeElement.style.left = x + ChartHTMLTooltip.PIXELS;
        this.el.nativeElement.style.top = y + ChartHTMLTooltip.PIXELS;
    }
    getDOMElement() {
        return this.el;
    }
}
ChartHTMLTooltip.PIXELS = 'px';

let GoogleChartComponent = class GoogleChartComponent {
    constructor(el, loaderService) {
        this.el = el;
        this.loaderService = loaderService;
        this.mouseOverListener = (item) => {
            const event = this.parseMouseEvent(item);
            event.tooltip = this.getHTMLTooltip();
            return event;
        };
        this.mouseOutListener = (item) => {
            const event = this.parseMouseEvent(item);
            return event;
        };
        this.selectListener = () => {
            const event = {
                message: 'select',
                row: null,
                column: null,
                selectedRowValues: [],
                selectedRowFormattedValues: [],
                columnLabel: ''
            };
            const s = this.wrapper.visualization.getSelection();
            const gs = s[s.length - 1];
            if (!gs) {
                event.message = 'deselect';
                return event;
            }
            const selection = gs;
            if (gs.row != null) {
                event.row = selection.row;
                const selectedRowValues = [];
                const selectedRowFormattedValues = [];
                const dataTable = this.wrapper.getDataTable();
                const numberOfColumns = dataTable.getNumberOfColumns();
                for (let i = 0; i < numberOfColumns; i++) {
                    selectedRowValues.push(dataTable.getValue(selection.row, i));
                    selectedRowFormattedValues.push(dataTable.getFormattedValue(selection.row, i));
                }
                event.selectedRowValues = selectedRowValues;
                event.selectedRowFormattedValues = selectedRowFormattedValues;
            }
            if (selection.column != null) {
                event.column = selection.column;
                event.columnLabel = this.getColumnLabelAtPosition(selection);
            }
            if (gs.name) {
                event.columnLabel = gs.name;
            }
            return event;
        };
        this.chartSelect = new EventEmitter();
        this.chartSelectOneTime = new EventEmitter();
        this.chartReady = new EventEmitter();
        this.chartReadyOneTime = new EventEmitter();
        this.chartError = new EventEmitter();
        this.chartErrorOneTime = new EventEmitter();
        this.mouseOver = new EventEmitter();
        this.mouseOverOneTime = new EventEmitter();
        this.mouseOut = new EventEmitter();
        this.mouseOutOneTime = new EventEmitter();
        this.regionClick = new EventEmitter();
        this.regionClickOneTime = new EventEmitter();
    }
    ngOnInit() {
        this.HTMLel = this.el.nativeElement.querySelector('div');
        if (Object.isExtensible(this.data)) {
            this.data.component = this;
        }
        this.options = this.data.options;
        this.init().then(() => {
            this.draw();
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loaderService.load();
            this.recreateWrapper();
        });
    }
    recreateWrapper() {
        if (this.wrapper === undefined || this.wrapper.getChartType() !== this.data.chartType) {
            this.dataTable = new GoogleChartsDataTable(this.data);
            this.dataTable.dataTableChanged.subscribe((dt) => {
                this._draw();
            });
            // see dataTable in https://developers.google.com/chart/interactive/docs/reference#google.visualization.drawchart
            let temp = this.data;
            if (this.data.firstRowIsData) {
                temp = Object.assign(temp, this.data);
                temp.dataTable = this.dataTable.getDataTable();
            }
            this.wrapper = new google.visualization.ChartWrapper(temp);
            this.registerChartWrapperEvents();
            /* Calling draw even without data is the only way to pass the HTMl element
               when using the chart in a dashboard. Don't do this in all other cases:
               it breaks formatters with remote data source, hence the conditional. */
            if (temp.dataTable === undefined && temp.dataSourceUrl === undefined) {
                try {
                    this.wrapper.draw(this.HTMLel);
                }
                catch (err) { }
            }
        }
    }
    _draw() {
        return __awaiter(this, void 0, void 0, function* () {
            const dt = this.dataTable.getDataTable();
            if (dt === undefined) {
                return;
            }
            this.convertOptions();
            this.recreateWrapper();
            this.wrapper.setOptions(this.options);
            this.wrapper.setDataTable(dt);
            this.wrapper.draw(this.HTMLel);
        });
    }
    getDataTable() {
        return this.dataTable;
    }
    draw(value) {
        if (value === undefined) {
            value = this.data;
        }
        this.options = value.options;
        this.dataTable.init(value);
    }
    getSelectorBySeriesType(seriesType) {
        const selectors = {
            bars: 'bar#%s#%r',
            haxis: 'hAxis#0#label',
            line: 'point#%s#%r',
            legend: 'legendentry#%s',
            area: 'point#%s#%r'
        };
        const selector = selectors[seriesType];
        return selector;
    }
    /**
     * Given a column number, counts how many
     * columns have rol=="data". Those are mapped
     * one-to-one to the series array. When rol is not defined
     * a column of type number means a series column.
     * @param column to inspect
     */
    getSeriesByColumn(column) {
        let series = 0;
        const dataTable = this.wrapper.getDataTable();
        for (let i = column - 1; i >= 0; i--) {
            const role = dataTable.getColumnRole(i);
            const type = dataTable.getColumnType(i);
            if (role === 'data' || type === 'number') {
                series++;
            }
        }
        return series;
    }
    getBoundingBoxForItem(item) {
        let boundingBox = { top: 0, left: 0, width: 0, height: 0 };
        if (this.cli) {
            const column = item.column;
            const series = this.getSeriesByColumn(column);
            const row = item.row;
            let seriesType = this.options.seriesType;
            if (this.options.series && this.options.series[series] && this.options.series[series].type) {
                seriesType = this.options.series[series].type;
            }
            if (seriesType) {
                let selector = this.getSelectorBySeriesType(seriesType);
                if (selector) {
                    selector = selector.replace('%s', series + '').replace('%c', column + '').replace('%r', row + '');
                    const box = this.cli.getBoundingBox(selector);
                    if (box) {
                        boundingBox = box;
                    }
                }
            }
        }
        return boundingBox;
    }
    getValueAtPosition(position) {
        if (position.row == null) {
            return null;
        }
        const dataTable = this.wrapper.getDataTable();
        const value = dataTable.getValue(position.row, position.column);
        return value;
    }
    getColumnTypeAtPosition(position) {
        const dataTable = this.wrapper.getDataTable();
        const type = dataTable.getColumnType(position.column) || '';
        return type;
    }
    getColumnLabelAtPosition(position) {
        const dataTable = this.wrapper.getDataTable();
        const type = dataTable.getColumnLabel(position.column) || '';
        return type;
    }
    getHTMLTooltip() {
        const tooltipER = new ElementRef(this.el.nativeElement.querySelector('.google-visualization-tooltip'));
        return new ChartHTMLTooltip(tooltipER);
    }
    parseMouseEvent(item) {
        const chartType = this.wrapper.getChartType();
        let eventColumn = item.column;
        if (eventColumn == null) {
            switch (chartType) {
                case 'Timeline':
                    eventColumn = this.wrapper.getDataTable().getNumberOfColumns() === 3 ? 0 : 1;
                    break;
                default:
                    eventColumn = 0;
            }
        }
        const eventRow = item.row;
        const myItem = {
            row: eventRow,
            column: eventColumn
        };
        const event = {
            position: item,
            boundingBox: this.getBoundingBoxForItem(myItem),
            value: this.getValueAtPosition(myItem),
            columnType: this.getColumnTypeAtPosition(myItem),
            columnLabel: this.getColumnLabelAtPosition(myItem)
        };
        return event;
    }
    unregisterEvents() {
        google.visualization.events.removeAllListeners(this.wrapper.getChart());
        google.visualization.events.removeAllListeners(this.wrapper);
    }
    registerChartEvents() {
        const chart = this.wrapper.getChart();
        this.cli = chart.getChartLayoutInterface ? chart.getChartLayoutInterface() : null;
        if (this.mouseOver.observers.length > 0) {
            google.visualization.events.addListener(chart, 'onmouseover', (item) => {
                const event = this.parseMouseEvent(item);
                event.tooltip = this.getHTMLTooltip();
                this.mouseOver.emit(event);
            });
        }
        if (this.mouseOverOneTime.observers.length > 0) {
            google.visualization.events.addOneTimeListener(chart, 'onmouseover', (item) => {
                const event = this.parseMouseEvent(item);
                event.tooltip = this.getHTMLTooltip();
                this.mouseOverOneTime.emit(event);
            });
        }
        if (this.mouseOut.observers.length > 0) {
            google.visualization.events.addListener(chart, 'onmouseout', (item) => {
                const event = this.parseMouseEvent(item);
                this.mouseOut.emit(event);
            });
        }
        if (this.mouseOutOneTime.observers.length > 0) {
            google.visualization.events.addOneTimeListener(chart, 'onmouseout', (item) => {
                const event = this.parseMouseEvent(item);
                this.mouseOutOneTime.emit(event);
            });
        }
        if (this.data.chartType === 'GeoChart') {
            if (this.regionClick.observers.length > 0) {
                google.visualization.events.addListener(chart, 'regionClick', (item) => {
                    this.regionClick.emit(item);
                });
            }
            if (this.regionClickOneTime.observers.length > 0) {
                google.visualization.events.addOneTimeListener(chart, 'regionClick', (item) => {
                    this.regionClick.emit(item);
                });
            }
        }
    }
    registerChartWrapperEvents() {
        google.visualization.events.addListener(this.wrapper, 'ready', () => {
            this.chartReady.emit({ message: 'Chart ready' });
        });
        google.visualization.events.addOneTimeListener(this.wrapper, 'ready', () => {
            this.chartReadyOneTime.emit({ message: 'Chart ready (one time)' });
            this.registerChartEvents();
        });
        google.visualization.events.addListener(this.wrapper, 'error', (error) => {
            this.chartError.emit(error);
        });
        google.visualization.events.addOneTimeListener(this.wrapper, 'error', (error) => {
            this.chartErrorOneTime.emit(error);
        });
        this.addListener(this.wrapper, 'select', this.selectListener, this.chartSelect);
        this.addOneTimeListener(this.wrapper, 'select', this.selectListener, this.chartSelectOneTime);
    }
    addListener(source, eventType, listenerFn, evEmitter) {
        google.visualization.events.addListener(source, eventType, () => {
            evEmitter.emit(listenerFn());
        });
    }
    addOneTimeListener(source, eventType, listenerFn, evEmitter) {
        google.visualization.events.addOneTimeListener(source, eventType, () => {
            evEmitter.emit(listenerFn());
        });
    }
    convertOptions() {
        try {
            this.options = google.charts[this.data.chartType].convertOptions(this.options);
        }
        catch (error) {
            return;
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], GoogleChartComponent.prototype, "data", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GoogleChartComponent.prototype, "chartReady", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GoogleChartComponent.prototype, "chartReadyOneTime", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GoogleChartComponent.prototype, "chartError", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GoogleChartComponent.prototype, "chartErrorOneTime", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GoogleChartComponent.prototype, "chartSelect", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GoogleChartComponent.prototype, "chartSelectOneTime", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GoogleChartComponent.prototype, "mouseOver", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GoogleChartComponent.prototype, "mouseOverOneTime", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GoogleChartComponent.prototype, "mouseOut", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GoogleChartComponent.prototype, "mouseOutOneTime", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GoogleChartComponent.prototype, "regionClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], GoogleChartComponent.prototype, "regionClickOneTime", void 0);
GoogleChartComponent = __decorate([
    Component({
        selector: 'google-chart',
        template: '<div></div>'
    }),
    __metadata("design:paramtypes", [ElementRef,
        GoogleChartsLoaderService])
], GoogleChartComponent);

let GoogleChartsDashboardComponent = class GoogleChartsDashboardComponent {
    constructor(el, loaderService) {
        this.el = el;
        this.loaderService = loaderService;
        this.el = el;
        this.loaderService = loaderService;
    }
    ngOnInit() {
        this.data.component = this;
        this.init().then(() => {
            if (!this.dataTable) {
                this.dataTable = new GoogleChartsDataTable(this.data);
                this.dataTable.dataTableChanged.subscribe((dt) => {
                    this._draw();
                });
            }
            this.draw();
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loaderService.load({ packages: ['controls'] });
            this.dashboard = new google.visualization.Dashboard(this.el.nativeElement.querySelector('div'));
            for (const b of this.data.bind) {
                let controls = b[0];
                let charts = b[1];
                if (!(controls instanceof Array)) {
                    controls = [controls];
                }
                if (!(charts instanceof Array)) {
                    charts = [charts];
                }
                for (const c of controls) {
                    yield c.component.ensureInit();
                }
                for (const c of charts) {
                    yield c.component.init();
                    const data = c.component.data;
                    if (data.dataTable !== undefined || data.dataSourceUrl !== undefined) {
                        throw Error('dataTable and dataSourceUrl cannot be specified when ' +
                            'chart is drawn in a Dashboard');
                    }
                }
                this.dashboard.bind(controls.map(x => x.component.wrapper), charts.map(x => x.component.wrapper));
            }
        });
    }
    draw(value) {
        this.dataTable.init(value);
    }
    _draw() {
        this.dashboard.draw(this.dataTable.getDataTable());
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], GoogleChartsDashboardComponent.prototype, "data", void 0);
GoogleChartsDashboardComponent = __decorate([
    Component({
        selector: 'google-charts-dashboard',
        template: '<div></div>'
    }),
    __metadata("design:paramtypes", [ElementRef,
        GoogleChartsLoaderService])
], GoogleChartsDashboardComponent);

let GoogleChartsControlComponent = class GoogleChartsControlComponent {
    constructor(el, loaderService) {
        this.el = el;
        this.loaderService = loaderService;
        this.el = el;
        this.loaderService = loaderService;
    }
    ngOnInit() {
        this.data.component = this;
    }
    ensureInit() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.wrapper) {
                return;
            }
            yield this.loaderService.load({ packages: ['controls'] });
            let opt;
            opt = Object.create(this.data);
            opt.containerId = this.el.nativeElement.querySelector('div');
            this.wrapper = new google.visualization.ControlWrapper(opt);
        });
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], GoogleChartsControlComponent.prototype, "data", void 0);
GoogleChartsControlComponent = __decorate([
    Component({
        selector: 'google-charts-control',
        template: '<div></div>'
    }),
    __metadata("design:paramtypes", [ElementRef,
        GoogleChartsLoaderService])
], GoogleChartsControlComponent);

let Ng2GoogleChartsModule = class Ng2GoogleChartsModule {
};
Ng2GoogleChartsModule = __decorate([
    NgModule({
        declarations: [
            GoogleChartComponent,
            GoogleChartsDashboardComponent,
            GoogleChartsControlComponent,
        ],
        providers: [
            GoogleChartsLoaderService
        ],
        exports: [
            GoogleChartComponent,
            GoogleChartsDashboardComponent,
            GoogleChartsControlComponent,
        ]
    })
], Ng2GoogleChartsModule);

function isComponent(chart) {
    return chart.wrapper !== undefined;
}
let GoogleChartEditor = class GoogleChartEditor {
    constructor(loaderService) {
        this.loaderService = loaderService;
    }
    createEditor() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.chartEditor !== undefined) {
                return;
            }
            yield this.loaderService.load({ packages: ['charteditor'] });
            this.chartEditor = new google.visualization.ChartEditor();
            google.visualization.events.addListener(this.chartEditor, 'ok', () => {
                const wrapper = this.chartEditor.getChartWrapper();
                this.comp.wrapper = wrapper;
                this.comp.data.chartType = wrapper.getChartType();
                if (this.comp.data.options !== undefined || Object.isExtensible(this.comp.data)) {
                    this.comp.data.options = wrapper.getOptions();
                }
                this.comp.wrapper.draw();
            });
        });
    }
    openDialog(chart, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.createEditor();
            return new Promise((resolve, reject) => {
                this.comp = isComponent(chart) ? chart : chart.component;
                this.chartEditor.openDialog(this.comp.wrapper, options);
                google.visualization.events.addListener(this.chartEditor, 'ok', () => {
                    resolve(this.comp.wrapper);
                });
                google.visualization.events.addListener(this.chartEditor, 'cancel', () => {
                    reject();
                });
            });
        });
    }
};
GoogleChartEditor.ɵprov = ɵɵdefineInjectable({ factory: function GoogleChartEditor_Factory() { return new GoogleChartEditor(ɵɵinject(GoogleChartsLoaderService)); }, token: GoogleChartEditor, providedIn: "root" });
GoogleChartEditor = __decorate([
    Injectable({
        providedIn: 'root'
    }),
    __metadata("design:paramtypes", [GoogleChartsLoaderService])
], GoogleChartEditor);

/*
 * Public API Surface of ng2-google-charts
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ChartHTMLTooltip, GoogleChartComponent, GoogleChartEditor, GoogleChartsControlComponent, GoogleChartsDashboardComponent, GoogleChartsLoaderService, Ng2GoogleChartsModule };
//# sourceMappingURL=ng2-google-charts.js.map
